(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{430:function(e,t,v){"use strict";v.r(t);var a=v(13),_=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"_1-vue-的生命周期是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-的生命周期是什么"}},[e._v("#")]),e._v(" 1. Vue 的生命周期是什么？")]),e._v(" "),v("p",[e._v("Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。")]),e._v(" "),v("h2",{attrs:{id:"_2-vue-的各个生命阶段是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-的各个生命阶段是什么"}},[e._v("#")]),e._v(" 2. Vue 的各个生命阶段是什么？")]),e._v(" "),v("p",[e._v("Vue 一共有 8 个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。")]),e._v(" "),v("p",[e._v("（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。")]),e._v(" "),v("p",[e._v("（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。")]),e._v(" "),v("p",[e._v("（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。")]),e._v(" "),v("p",[e._v("（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。")]),e._v(" "),v("p",[e._v("（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。")]),e._v(" "),v("p",[e._v("（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。")]),e._v(" "),v("p",[e._v("（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。")]),e._v(" "),v("p",[e._v("（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。")]),e._v(" "),v("p",[e._v("当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。")]),e._v(" "),v("h2",{attrs:{id:"_3-vue-组件间的参数传递方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue-组件间的参数传递方式"}},[e._v("#")]),e._v(" 3.Vue 组件间的参数传递方式？")]),e._v(" "),v("h3",{attrs:{id:"_3-1-父子组件间通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-父子组件间通信"}},[e._v("#")]),e._v(" 3.1 父子组件间通信")]),e._v(" "),v("p",[e._v("第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事\n件来向父组件发送数据。")]),e._v(" "),v("p",[e._v("第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组\n件，这样也可以实现通信。")]),e._v(" "),v("p",[e._v("第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件\n中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。")]),e._v(" "),v("h3",{attrs:{id:"_3-2-兄弟组件间通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-兄弟组件间通信"}},[e._v("#")]),e._v(" 3.2 兄弟组件间通信")]),e._v(" "),v("p",[e._v("第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实\n例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。")]),e._v(" "),v("p",[e._v("第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。")]),e._v(" "),v("h3",{attrs:{id:"_3-3-任意组件之间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-任意组件之间"}},[e._v("#")]),e._v(" 3.3 任意组件之间")]),e._v(" "),v("p",[e._v("使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。")]),e._v(" "),v("p",[e._v("如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候\n可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个\n公共数据进行读写操作，这样达到了解耦的目的。")]),e._v(" "),v("h2",{attrs:{id:"_4-computed-和-watch-的差异"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-computed-和-watch-的差异"}},[e._v("#")]),e._v(" 4.computed 和 watch 的差异？")]),e._v(" "),v("p",[e._v("（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。")]),e._v(" "),v("p",[e._v("（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。")]),e._v(" "),v("p",[e._v("（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。")]),e._v(" "),v("h2",{attrs:{id:"_5-vue-router-中的导航钩子函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-router-中的导航钩子函数"}},[e._v("#")]),e._v(" 5. vue-router 中的导航钩子函数")]),e._v(" "),v("p",[e._v("（1）全局的钩子函数 beforeEach 和 afterEach")]),e._v(" "),v("p",[e._v("beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。")]),e._v(" "),v("p",[e._v("（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。")]),e._v(" "),v("p",[e._v("（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组\n件内部直接进行定义的。")]),e._v(" "),v("h2",{attrs:{id:"_6-vue-常用的修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-常用的修饰符"}},[e._v("#")]),e._v(" 6.vue 常用的修饰符？")]),e._v(" "),v("p",[e._v(".prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；")]),e._v(" "),v("h2",{attrs:{id:"_7-vue-中-key-值的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-中-key-值的作用"}},[e._v("#")]),e._v(" 7.vue 中 key 值的作用？")]),e._v(" "),v("h3",{attrs:{id:"vue-中-key-值的作用可以分为两种情况来考虑。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-中-key-值的作用可以分为两种情况来考虑。"}},[e._v("#")]),e._v(" vue 中 key 值的作用可以分为两种情况来考虑。")]),e._v(" "),v("p",[e._v("第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。")]),e._v(" "),v("p",[e._v("第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。")]),e._v(" "),v("h2",{attrs:{id:"_8-computed-和-watch-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-computed-和-watch-区别"}},[e._v("#")]),e._v(" 8.computed 和 watch 区别？")]),e._v(" "),v("p",[e._v("computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。")]),e._v(" "),v("p",[e._v("watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。")]),e._v(" "),v("h2",{attrs:{id:"_9-keep-alive-组件有什么作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-keep-alive-组件有什么作用"}},[e._v("#")]),e._v(" 9.keep-alive 组件有什么作用？")]),e._v(" "),v("p",[e._v("如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。")]),e._v(" "),v("h2",{attrs:{id:"_10-vue-中-mixin-和-mixins-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-中-mixin-和-mixins-区别"}},[e._v("#")]),e._v(" 10. vue 中 mixin 和 mixins 区别？")]),e._v(" "),v("p",[e._v("mixin 用于全局混入，会影响到每个组件实例。")]),e._v(" "),v("p",[e._v("mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并")]),e._v(" "),v("h2",{attrs:{id:"_11-开发中常用的几种-content-type"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-开发中常用的几种-content-type"}},[e._v("#")]),e._v(" 11.开发中常用的几种 Content-Type ？")]),e._v(" "),v("p",[e._v("（1）application/x-www-form-urlencoded")]),e._v(" "),v("p",[e._v("浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL\n转码。")]),e._v(" "),v("p",[e._v("（2）multipart/form-data")]),e._v(" "),v("p",[e._v("该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。")]),e._v(" "),v("p",[e._v("（3）application/json")]),e._v(" "),v("p",[e._v("告诉服务器消息主体是序列化后的 JSON 字符串。")]),e._v(" "),v("p",[e._v("（4）text/xml")]),e._v(" "),v("p",[e._v("该种方式主要用来提交 XML 格式的数据。")])])}),[],!1,null,null,null);t.default=_.exports}}]);